/* ç²¾ç®€ç‰ˆï¼šå»å†—ä½™ã€ä¿®ä¸¤ Bugï¼ˆå…¨å±€å˜é‡ä¸²å‘³ + æ— åç¼€ songlistï¼‰ */
const SONG_FILE_CONFIG = {
  required: ['base.jpg', 'base.ogg', 'slst.txt'],
  optional: ['songlist.txt', 'base.mp3']
};
const SUPABASE_URL = 'https://hwlzunfsvcjxtjdeiuns.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh3bHp1bmZzdmNqeHRqZGVpdW5zIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEwOTg3MzMsImV4cCI6MjA3NjY3NDczM30.44XtqidKR61vv9znx2LW6oGGZAP-javBk5Gpweli5T8';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
const DIFF_MAP = ['Past', 'Present', 'Future', 'Beyond', 'Eternal'];

let currentFile, extractedFiles, isBatch = false,
    batchTotal = 0, batchDone = 0, batchFail = 0,
    manualTitle = '', manualComposer = '', manualCharter = '', manualBpm = 200,
    manualDiffInputs = {}, manualAffList = [], manualAffIdx = 0,
    bgFile = '', isManual = false, userId = 'default_user';

/* === DOM å·¥å…· === */
const $ = id => document.getElementById(id);
const toggle = (show, ...hide) => {
  [show].flat().forEach(i => $(i).classList.remove('hidden'));
  hide.forEach(i => $(i).classList.add('hidden'));
};

/* === åˆå§‹åŒ– === */
document.addEventListener('DOMContentLoaded', () => {
  setInterval(() => $('currentTime').textContent = `[${new Date().toLocaleTimeString('zh-CN')}]`, 1000);
  setupListeners();
  updateCounter();
});

function setupListeners() {
  $('fileInput').addEventListener('change', e => e.target.files.length && startBatch([...e.target.files]));
  $('uploadArea').addEventListener('drop', e => {
    e.preventDefault();
    const zips = [...e.dataTransfer.files].filter(f => f.name.endsWith('.zip'));
    zips.length ? startBatch(zips) : addLog('error', 'è¯·ä¸Šä¼  ZIP');
  });
  $('continueBtn').addEventListener('click', handleContinue);
  $('backgroundFileInput').addEventListener('change', e => e.target.files.length && handleBg(e.target.files[0]));
  $('skipBackgroundBtn').addEventListener('click', () => { bgFile = 'SKIPPED'; continueProc(); });
  ['dragover', 'dragleave'].forEach(ev => {
    $('uploadArea').addEventListener(ev, e => e.preventDefault());
    $('backgroundUploadArea').addEventListener(ev, e => e.preventDefault());
  });
}

/* === æ‰¹å¤„ç†å…¥å£ === */
function startBatch(files) {
  isBatch = true;
  batchTotal = files.length;
  batchDone = batchFail = 0;
  currentFile = null;
  resetGlobals();
  addLog('info', `=== æ‰¹é‡ï¼šå…± ${batchTotal} ä¸ª ===`);
  toggle('progressSection', 'inputSection', 'backgroundInputSection', 'resultSection', 'errorSection');
  updateProgress(0, `ç­‰å¾…ï¼ˆ0/${batchTotal}ï¼‰`);
  nextFile(files);
}

function nextFile(files) {
  if (batchDone + batchFail >= batchTotal) return endBatch();
  const idx = batchDone + batchFail;
  currentFile = files[idx];
  resetGlobals();
  addLog('info', `\n--- ${idx + 1}/${batchTotal}ï¼š${currentFile.name} ---`);
  processFile(currentFile)
    .then(() => { batchDone++; updateProgress(Math.round((batchDone + batchFail) / batchTotal * 100), `å®Œæˆ ${batchDone}/${batchTotal}`); nextFile(files); })
    .catch(e => {
      if (e.message === 'waitManual' || e.message === 'waitBg') return; // åœç­‰ç”¨æˆ·
      batchFail++; addLog('error', `${currentFile.name} å¤±è´¥ï¼š${e.message}`);
      nextFile(files);
    });
}

function resetGlobals() {
  extractedFiles = null; manualTitle = ''; manualComposer = ''; manualCharter = ''; manualBpm = 200;
  manualDiffInputs = {}; manualAffList = []; manualAffIdx = 0; bgFile = ''; isManual = false;
}

/* === å•æ–‡ä»¶æµç¨‹ === */
async function processFile(file) {
  if (file.size > 50 * 1024 * 1024) throw new Error('>50MB');
  if (!extractedFiles) {
    extractedFiles = normalize(await unzip(file));
    addLog('info', `è§£å‹ï¼š${Object.keys(extractedFiles).length} æ–‡ä»¶`);
  }
  if (!bgFile && !isManual) { toggle('backgroundInputSection', 'progressSection'); throw new Error('waitBg'); }
  const info = await getSongInfo(extractedFiles);
  await buildConfigs(extractedFiles, info);
  const blob = await packARCPKG(extractedFiles, info);
  const url = URL.createObjectURL(blob);
  showSuccess(info.title, url, `${info.title.replace(/[^\w\-]/g, '_')}.arcpkg`, blob.size);
  bumpCounter();
  setTimeout(() => URL.revokeObjectURL(url), 60000);
}

/* === è§£å‹ + è§„èŒƒåŒ– === */
async function unzip(file) {
  const zip = await JSZip.loadAsync(file);
  const f = {};
  for (const z of Object.values(zip.files)) {
    if (z.dir || z.name.includes('__MACOSX')) continue;
    const name = z.name.split('/').pop();
    if (name) f[name] = await z.async('arraybuffer');
  }
  return f;
}

function normalize(files) {
  const jpg = Object.keys(files).filter(n => n.toLowerCase().endsWith('.jpg'));
  const pick = jpg.find(x => /1080[_-]?base\.jpg$/i.test(x)) || jpg.find(x => /(^|[_-])base\.jpg$/i.test(x)) || jpg.find(x => /background/i.test(x));
  if (pick && !files['base.jpg']) files['base.jpg'] = files[pick];
  if (!files['base.ogg'] && files['base.mp3']) files['base.ogg'] = files['base.mp3'];
  return files;
}

/* === æ­Œæ›²ä¿¡æ¯ === */
async function getSongInfo(files) {
  const cfg = ['slst.txt', 'songlist.txt', 'songlist'].find(n => files[n]);
  if (!cfg) { toggle('inputSection', 'progressSection'); isManual = true; throw new Error('waitManual'); }
  const txt = new TextDecoder().decode(files[cfg]);
  let data = JSON.parse(txt);
  if (data.songs?.length) data = data.songs[0];
  const affs = Object.keys(files).filter(n => n.endsWith('.aff'));
  if (!affs.length) throw new Error('æ—  .aff');
  const info = {
    id: data.id || `song_${Date.now()}`,
    title: data.title_localized?.en || data.title || 'Unknown',
    artist: data.artist || 'Unknown',
    bpm: data.bpm_base || +data.bpm || 200,
    difficulties: []
  };
  affs.forEach(n => {
    const m = n.match(/^(\d+)\.aff$/);
    if (m) {
      const rc = +m[1];
      const diff = (data.difficulties || []).find(d => d.ratingClass === rc) || {};
      info.difficulties.push({ ratingClass: rc, rating: diff.rating || -1, chartDesigner: diff.chartDesigner || '' });
    }
  });
  if (!info.difficulties.length) throw new Error('æ— æœ‰æ•ˆéš¾åº¦');
  return info;
}

/* === æ‰‹åŠ¨æ¨¡å¼ === */
function handleContinue() {
  if ($('perAffControls').style.display !== 'none') return saveAffAndNext();
  manualTitle = $('titleInput').value.trim() || currentFile.name.replace(/\.zip$/i, '');
  manualComposer = $('composerInput').value.trim();
  manualBpm = +$('bpmInput').value || 200;
  isManual = true;
  buildManualAffList();
  toggleAffSeq();
}

function buildManualAffList() {
  const affs = Object.keys(extractedFiles).filter(n => n.endsWith('.aff'));
  manualAffList = affs.map(n => {
    const m = n.match(/^(\d+)\.aff$/);
    return m ? { rc: +m[1], file: n } : null;
  }).filter(Boolean).sort((a, b) => a.rc - b.rc);
  manualAffList.forEach(x => manualDiffInputs[x.rc] = { chartDesigner: '', rating: '' });
}

function toggleAffSeq() {
  const groups = $('inputSection').querySelectorAll('.input-group');
  [...groups].slice(0, 3).forEach(g => g.style.display = 'none');
  $('perAffControls').style.display = 'block';
  manualAffIdx = 0;
  renderAff();
}

function renderAff() {
  const it = manualAffList[manualAffIdx];
  if (!it) return finishAffSeq();
  $('perAffProgress').textContent = `${manualAffIdx + 1}/${manualAffList.length}ï¼š${it.file}ï¼ˆ${DIFF_MAP[it.rc] || `Lv${it.rc}`}ï¼‰`;
  $('perAffContainer').innerHTML = `
    <div class="aff-row">
      <span class="aff-meta">${it.file} ï¼ˆ${DIFF_MAP[it.rc] || `Lv${it.rc}`}ï¼‰</span>
      <input id="charter${it.rc}" type="text" placeholder="è°±å¸ˆ" value="${manualDiffInputs[it.rc].chartDesigner}">
      <input id="rating${it.rc}" type="number" placeholder="éš¾åº¦" value="${manualDiffInputs[it.rc].rating}">
    </div>`;
}

function saveAffAndNext() {
  const it = manualAffList[manualAffIdx];
  manualDiffInputs[it.rc].chartDesigner = $(`charter${it.rc}`).value.trim() || manualComposer || 'Unknown';
  manualDiffInputs[it.rc].rating = +$(`rating${it.rc}`).value || -1;
  manualAffIdx++;
  manualAffIdx >= manualAffList.length ? finishAffSeq() : renderAff();
}

function finishAffSeq() {
  $('perAffControls').style.display = 'none';
  toggle('progressSection', 'inputSection');
  continueProc();
}

/* === é…ç½®ç”Ÿæˆ === */
async function buildConfigs(files, info) {
  const packId = info.set || 'pack001';
  files.packlist = new TextEncoder().encode(JSON.stringify({ packs: [{ id: packId, name_localized: { en: `Pack ${packId}` } }] }, null, 2));
  const songlist = { songs: [info] };
  files.songlist = new TextEncoder().encode(JSON.stringify(songlist, null, 2));
}

/* === æ‰“åŒ… === */
async function packARCPKG(files, info) {
  const zip = new JSZip();
  const songId = info.id;
  const dir = zip.folder(songId);
  const needs = ['base.jpg', 'base.ogg', 'project.arcproj', ...Object.keys(files).filter(n => n.endsWith('.aff'))];
  if (bgFile && bgFile !== 'SKIPPED') needs.push(bgFile);
  needs.forEach(n => files[n] && dir.file(n, files[n]));
  zip.file('index.yml', jsyaml.dump([{ directory: songId, identifier: `${userId}.${songId}`, settingsFile: 'project.arcproj', version: 0, type: 'level' }]));
  return zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 9 } });
}

/* === ç»§ç»­å¤„ç† === */
function continueProc() {
  toggle('progressSection', 'inputSection', 'backgroundInputSection');
  processFile(currentFile).catch(() => {});
}

function handleBg(file) {
  readFileAsArrayBuffer(file).then(b => {
    bgFile = file.name;
    extractedFiles[bgFile] = b;
    continueProc();
  });
}

/* === å·¥å…· === */
const readFileAsArrayBuffer = f => new Promise((resolve, reject) => {
  const r = new FileReader();
  r.onload = () => resolve(r.result);
  r.onerror = () => reject(new Error('read fail'));
  r.readAsArrayBuffer(f);
});

function addLog(type, msg) {
  const box = $('logsContainer');
  box.insertAdjacentHTML('beforeend', `<div class="log-entry ${type}"><span class="log-time">[${new Date().toLocaleTimeString('zh-CN')}]</span><span class="log-message">${msg}</span></div>`);
  box.scrollTop = box.scrollHeight;
}

function updateProgress(p, txt) {
  $('progressText').textContent = txt || `${p}%`;
  $('progressBar').value = p;
}

function showSuccess(title, url, name, size) {
  toggle('resultSection', 'errorSection');
  $('resultContent').insertAdjacentHTML('beforeend', `
    <div style="margin-bottom:20px;border-bottom:1px dashed #eee;padding-bottom:20px;">
      <p>ã€Š${title}ã€‹æ‰“åŒ…å®Œæˆ</p>
      <div style="margin-top:15px;"><a href="${url}" download="${name}" class="download-btn">ğŸ“¥ ${name}</a></div>
      <p style="margin-top:15px;color:#7f8c8d;">å¤§å°ï¼š${(size / 1024 / 1024).toFixed(2)}MB</p>
    </div>`);
  addLog('success', `å®Œæˆï¼š${name}`);
}

async function bumpCounter() {
  try {
    const { data } = await supabase.from('times').select('times').single();
    const n = (data?.times || 0) + 1;
    await supabase.from('times').update({ times: n }).eq('id', 1);
    $('successCount').textContent = n;
  } catch {}
}

async function updateCounter() {
  try {
    const { data } = await supabase.from('times').select('times').single();
    $('successCount').textContent = data?.times || 0;
  } catch {}
}

function endBatch() {
  isBatch = false;
  addLog('success', `=== æ‰¹é‡å®Œæˆï¼šæˆåŠŸ ${batchDone} / æ€»è®¡ ${batchTotal} ===`);
}
